\chapter{Aufbau des Live-Tuners}
\label {Aufbau des Live Tuners}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Aufbau des Live Tuners%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In diesem Kapitel wird der eigentliche Aufbau der Software des Live-Tuners näher beschrieben. Eine erste Übersicht bietet hier das UML-Klassendiagramm\vref{UML Klassendiagramm}.

\begin{figure}[H]
	\centering
  \includegraphics[width=1.1\textwidth]{Bilder3/UMLClassDiagram1.pdf}
	\caption{UML-Klassendiagramm}
	\label{UML Klassendiagramm}
\end{figure}

Wie leicht zu erkennen ist, baut sich der Live-Tuner aus drei großen Komponenten auf:

\begin{itemize}
	\item \textit{Graphische Oberfläche} \vref{Graphische Oberfläche}
	\item \textit{Simulation} \vref{Simulation}
	\item \textit{Speichern und Laden} \vref{Speichern und Laden}
\end{itemize}

Diese drei Komponenten werden nun in den folgenden Kapiteln näher beleuchtet.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Graphische Oberfläche%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graphische Oberfläche}
\label {Graphische Oberfläche}

\begin{description}
	 
		\item \textbf{Das Ziel}
		
		Das Hauptziel der Oberfläche ist es, diese so zu konzipieren, dass eine Veränderung an einem der einstellbaren Parametern sofort zu einer Veränderung am Plot führt, also sozusagen "Live". So ist es leichter, ein Gespür für die verschiedenen einstellbaren Werte zu erlangen. Des Weiteren soll dem Nutzer viel Komfort entgegengebracht werden, z.B. gibt das Programm selbst vor, welche Regler zu welcher Regelstrecke sinnvoll sind und welche eher nicht. \newline
		
		Von der Aufgabestellung war vorgegeben, die Oberfläche mit der Windows Presentation Foundation (WPF) zu erstellen. In dieser ist es zwar noch möglich, die Oberfläche in C\# zu konfigurieren, jedoch nicht mehr so, wie es in den älteren Windows-Forms Anwendungen der Fall war. Die Einstellungen für die Oberfläche werden nun in einem XML-Dokument vorgenommen. 

\begin{figure}[H]
	\centering
  \includegraphics[width=1\textwidth]{Bilder3/Live_Tuner.png}
	\caption{Graphische Oberfläche des Live-Tuners}
	\label{Graphische Oberfläche des Live Tuners}
\end{figure}

		\item \textbf{Live Plot}

		Der Live Plot hat die Aufgabe die ihm übergebenen Werte in einem Graph darzustellen. Da die Oberfläche mit dem Windows Presentation Foundation (WPF) Oberflächendesigner erstellt wurde, wurde für die Darstellung des Graphen das WPF-Toolkit verwendet. Dieses enthält alle rudimentären Darstellungsformen und -einstellungen für verschiedene Graphentypen. Für den Graph wurde der Graphentyp "LineSeries" verwendet. Diese plottet anhand von x- und y-Werten den Graphen. \newline
		Einer der Vorteile des WPF-Toolkits ist, dass der Graph sich je nach den übergebenen Werten automatisch skaliert. Die Größenordnung der Werte werden aber nicht angepasst. Dies muss in den Einstellungen separat durchgeführt werden. Die Ausgabe der Werte wurde nun so angepasst, dass diese vorher in eine Exponentialschreibweise umgeformt werden. So können nun extrem große, aber auch extrem kleine Werte ausgegeben werden.   		   

		\item \textbf{Strecke und Regler}		

		Unter diesen Punkten kann die Regelstrecke und der dazu passende Regler eingestellt werden. Die Oberfläche gibt automatisch je nach gewählter Regelstrecke den passenden Regler vor. Auch hier werden die Werte der verschiedenen Parameter in Exponentialschreibweise dargestellt. Die Einstellungen für die einzelnen Parameter werden mit Hilfe der Base Slider 
		vorgenommen.

		\item \textbf{Base Slider}	
		
		Die Einstellungsmöglichkeiten für die Regler bzw. Strecke sind alle gleich. Deshalb wurde ein separates Oberflächenobjekt erstellt, der sogenannte Base Slider. Dieser besteht im wesentlichen aus einem Anfangswert, zudem dann noch ein zweiter Wert hinzuaddiert wird. Dabei wird der zweite Wert per Slider zwischen den Werten 1 und -1 eingestellt und mit einem Faktor multipliziert. Durch diesen Trick kann ideal in dem gewünschten Zahlenbereich gearbeitet werden.  

		\item \textbf{Infos \& Einstellungen}
		
		Unter dem Punkt Infos \& Einstellungen befinden sich folgende Punkte:
		\begin{itemize}
		\item \textit{Regelkreis} \newline
		Ein Bild des verwendeten Regelkreises, welcher simuliert wird. 
		\item \textit{Störung} \newline
		Hier lassen sich Störungen in den Regelkreis einspeisen.
		\item \textit{Solver} \newline
		Unter dem Punkt Solver lässt sich die Schrittweite der Simulation, sowie der Endzeitpunkt der Simulation bestimmen. Darüber hinaus gibt es hier die Möglichkeit für den Plot weniger Werte zu verwenden als die Simulation berechnet. Dieses Feature ermöglicht es einem die aufzuwendende Rechenleistung zu verringern, da die Berechnung für die Simulation sehr viel geringer ist als die Berechnung des Plots.
		\item \textit{Quellen} \newline
		Das Programm wurde mithilfe der angegebenen Quellen entwickelt und erstellt.
		\item \textit{Save \& Load}
		
		Alle Einstellungen lassen sich mit dem Save-Befehl in einer Datei speichern. Mit dem Load-Befehl kann so zu einem
		späterem Zeitpunkt auf die Einstellungen zurückgegriffen werden.
		\item \textit{Live Plot} \newline
		Wenn das Häkchen bei Live Plot gesetzt wird, werden die berechneten Werte direkt geplottet. Will man sehr viele Werte auf einmal ändern, so empfiehlt es sich dieses Häkchen zu deaktivieren, um schneller arbeiten zu können.
		\end{itemize}				

		\item \textbf{Warnings}	

Bei den Solver-Einstellungen ist es dem Benutzer frei gestellt diese an seine Bedürfnisse anzupassen. Jedoch gibt es Einstellungskombinationen, die sehr rechenintensiv sind. Dies ist erstens nicht notwendig, und kann zweitens zu sehr langen Simulationsdauern führen. Aus diesem Grund wird dem Benutzer bei kritischen Eingaben eine Warning ausgegeben, welche Sie in Abbildung\vref{Warnung für rechenintensive Solver Einstellungen} sehen können.
							
\begin{figure}[H]
	\centering
  \includegraphics[width=1\textwidth]{Bilder3/warning.png}
	\caption{Warnung für rechenintensive Solver Einstellungen}
	\label{Warnung für rechenintensive Solver Einstellungen}
\end{figure}
							
\end{description}

\newpage 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Simulation%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simulation}
\label {Simulation}

Durch die komplette Simulation eines Regelkreises soll dem Benutzer graphisch gezeigt werden, wie gut sein aktueller Regler ausgelegt ist.
Ein allgemeiner Regelkreis besteht aus folgenden Komponenten:

\begin{figure}[H]
	\centering
  \includegraphics[width=1\textwidth]{Bilder3/Regelkreis.pdf}
	\caption{Allgemeiner Aufbau eines Regelkreises}
	\label{fig:Aufgabe11}
\end{figure}

\begin{itemize}
	\item \textit{Soll-Wert}
	
	Gewünschter Wert, welcher erreicht werden soll.
	\item \textit{Vergleich Soll-Ist}
	
	Durch die Addition(+/-) wird ein Soll-Ist Vergleich gemacht, welcher zum Regler geht.
	\item \textit{Regler}
	
	Der Regler ist eine Übertragungsfunktion, und je nach Bedarf ein P-, I-, oder PI-Regler.
	\item \textit{Störung}
	
	Durch die Störung sollen mögliche Störfaktoren mitsimuliert werden.
	\item \textit{Strecke}	
	
	Die Strecke ist die Übertragungsfunktion des physikalischen Systems (Motor, elektrische Schaltung,...)
	\item \textit{Plot}
	
	Der Plot beobachtet quasi die einzelnen Simulationsschritte und gibt diese graphisch aus.
\end{itemize}

Die Idee für die softwaretechnische Umsetzung einer Simulation besteht nun darin, dass jede einzelne Komponente des Regelkreises durch eine einzelne Klasse beschrieben wird.
Bei einer Simulation berechnet nun jeder Teilnehmer einen kleinen Zeitschritt und gibt das Ergebnis an den nächsten Teilnehmer im Regelkreis weiter. Dies wird so oft wie erwünscht wiederholt und am Schluss als Gesamtergebnis zurückgegeben.

\begin{description}

		\item \textbf{Die Problematik}

\begin{itemize}
	\item Die ganzen Berechnungen zur Simulation eines Regelkreises sind sehr kompliziert, wie kann man es nach außen vereinfachen, sodass man sich nicht hinein denken muss, wenn man dieses verwenden will?
	\item Die einzelnen Klassen im Regelkreis für Regler und Strecke können je nach Anwenderbedarf unterschiedlich sein! Wie können nun diese Klassen miteinander kommunizieren, ohne sich direkt kennen zu müssen? 
\end{itemize}

				
		\item \textbf{Lösungsansatz}
		
Einen sehr guten Lösungsansatz bieten hier die Schablonen der Entwurfsmuster (Design Patterns). Hierbei handelt es sich um bewährte Lösungsschablonen für wiederkehrende Entwurfsprobleme in der Softwareentwicklung.

Um diese zwei Probleme zu behandeln wurden folgende zwei Entwurfsmuster ausgewählt:

\newpage				
\subsection{Fassade Entwurfsmuster}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{Fassade-Entwurfsmuster}	

		\item \textbf{Beschreibung des Entwurfsmusters (wiki)}
		
\textit{Wenn ein Subsystem viele technisch orientierte Klassen enthält, die selten von außen verwendet werden, hilft es, eine Fassade zu verwenden. Die Fassade ist eine Klasse mit ausgewählten Methoden, die eine häufig benötigte Untermenge an Funktionalität des Subsystems umfasst. Sie delegiert die Funktionalität an andere Klassen des Subsystems und vereinfacht dadurch den Umgang mit dem Subsystem.}


		\item \textbf{Verwendung der Fassade}

Wie im Ausschnitt des UML-Diagramms\vref{UML Klassendiagramm2} gut zu erkennen ist, bildet die Klasse \textit{Simulator} eine Fassade in diesem Projekt. 
	
\begin{figure}[H]
	\centering
  \includegraphics[width=0.9\textwidth]{Bilder3/UMLClassDiagram2.pdf}
	\caption{Klasse "`Simulator"' als Fassade}
	\label{UML Klassendiagramm2}
\end{figure}

Der \textit{Simulator} kümmert sich um die komplette Verwaltung der einzelnen Klassen einer Simulation, vernetzt sie miteinander und leitet die einzelnen Berechnungen. Er merkt sich in einem Array von Objekten, welche das Interface ISimulatable implementieren, in welcher Reihenfolge die einzelnen Objekte bei einer Simulation aufgerufen werden müssen.

Durch diesen Einsatz wird die Komplexität einer Simulation auf ein Minimum von zwei Funktionen heruntergebrochen:

\begin{itemize}
	\item \textit{float[,] simulate(float Ts, float Tend)}
	
	Simuliere den aktuellen Regelkreis mit den festen kleinen Zeitschritten $T_{s}$ bis zur Endzeit $T_{end}$. Gib das Ergebnis zurück.
	
	\item \textit{bool replace\_in\_Schematic\_at\_pos(int position, ISimulatable x)}
	
	Ersetze im Array an der Stelle \textit{position} das Objekt durch x. Löse die alten Vernetzungen und setze neue. (Hierdurch können die Objete im Regelkreis vertauscht werden.)
\end{itemize}
 
\subsection{Beobachter-Entwurfsmuster}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{Beobachter Entwurfsmuster}	
		
		\item \textbf{Beschreibung des Entwurfsmusters (wiki)}
		
\textit{Allgemein finden Beobachter-Muster Anwendung, wenn eine Abstraktion mehrere Aspekte hat, die von einem anderen Aspekt derselben Abstraktion abhängen, die Änderung eines Objekts Änderungen an anderen Objekten nach sich zieht oder ein Objekt andere Objekte benachrichtigen soll, ohne diese im Detail zu kennen.}	

		\item \textbf{Verwendung des Beobachter-Musters}

Dieses Muster bietet sich ideal für das zweite Problem an, da sich die einzelnen Objekte in einem Regelkreis nicht direkt kennen müssen, um sich gegenseitig benachrichtigen zu können.
Diese Benachrichtigungen sind immer dann erforderlich, wenn ein Objekt im Regelkreis einen Zeitschritt für sich berechnet hat. Ist die Berechnung fertig, so wird das Ergebnis an das beobachtende Objekt weitergegeben.
Anschaulich bedeutet dies, dass alle Verbindungen im Regelkreis\vref{Benachrichtigungen in einem Regelkreis} solche Benachrichtigungen (events) sind.

\begin{figure}[H]
	\centering
  \includegraphics[width=1\textwidth]{Bilder3/Regelkreis.pdf}
	\caption{Benachrichtigungen in einem Regelkreis}
	\label{Benachrichtigungen in einem Regelkreis}
\end{figure}

\newpage

Hierdurch ist nun klar, wie das Interface aufgebaut sein muss, welches eine Klasse implementiert, um simulierbar zu sein:

\begin{figure}[H]
	\centering
  \includegraphics[width=0.5\textwidth]{Bilder3/Interface_IS.pdf}
	\caption{Interface für Simulation}
	\label{Interface für Simulation}
\end{figure}



\begin{itemize}
	\item \textit{event OutputEventHandler I\_am\_finish}
	
	Dieses event wird gefeuert, wenn eine Berechnung fertig ist.
	\item \textit{void set\_input(float x\_in)}
		
	Setze den Eingangswert für die Berechnung des nächsten Zeitschrittes.
	\item \textit{float do\_one\_step(float Ts)}
		
	Berechne den Ausgangswert aus dem Eingangswert und feuere das Event \textit{I\_am\_finish}.
	\item \textit{void reset()}	
	
	Leere den Speicher der Vergangenheit.
	
	\item \textit{void connect\_this\_Input\_with(ISimulatable Target\_output)}

	Beobachte den Ausgang des anderen Objektes, indem du deinen Eingang mit diesem Ausgang verbindest.
	\item \textit{void disconnect\_this\_Input\_from(ISimulatable Target\_output)}
	
	Löse die Beobachtung auf.
\end{itemize}

Durch dieses Interface und die Verwendung des Simulators kann nun der Regelkreis simuliert werden.
Im UML-Sequenzdiagramm\vref{UML Sequenzdiagramm} ist eine Benutzeranfrage an eine Simulation skizziert.
		
\begin{figure}[H]
	\centering
  \includegraphics[width=1\textwidth]{Bilder3/UMLSequenceDiagram1.pdf}
	\caption{UML-Sequenzdiagramm für eine Simulationsanfrage}
	\label{UML Sequenzdiagramm}
\end{figure}

Wie deutlich zu erkennen ist, benutzt die graphische Oberfläche die Fassade des Simulators um eine Simulation zu starten.
Dieser ruft nach und nach die einzelnen Komponenten des Regelkreises dazu auf einen Zeitschritt zu berechnen. 
Wie klar zu erkennen ist, kennen sich die einzelnen Komponenten des Regelkreises nicht, sondern beobachten sich nur gegenseitig, um Informationen zu erhalten.

Haben alle Komponenten einen Zeitschritt berechnet, so wird die Schleife erneut durchlaufen, bis die gewünschte Anzahl an Simulationsschritten erreicht ist, und das Gesamtergebnis an die graphische Oberfläche zurück gegeben wird.
				
\end{description}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Speichern und Laden%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Speichern und Laden}
\label {Speichern und Laden}
\begin{description}
		
		\item \textbf{Die Motivation}

Ein entscheidendes Feature eines Software-Tools ist selbstverständlich die Möglichkeit seine Arbeit speichern zu können, 
damit die Möglichkeit besteht diese zu archivieren und zu einem späteren Zeitpunkten auf den alten Stand zurückzugreifen.
Ein weiterer großer Vorteil besteht darin, dass man die gespeicherte Datei ganz einfach an Arbeitskollegen verteilen kann, damit diese sich die Auslegung anschauen können.

Aus diesem Gedanken heraus ist es eine Notwendigkeit ein solches Feature für den Live-Tuner bereitzustellen.
				
		\item \textbf{Umsetzung}

Im UML-Klassendiagramm\vref{UML Klassendiagramm für das Speichern und Laden} sehen Sie das Lösungskonzept für dieses Feature.
		
\begin{figure}[H]
	\centering
  \includegraphics[width=1\textwidth]{Bilder3/UMLClassDiagram3.pdf}
	\caption{UML-Klassendiagramm für das Speichern und Laden}
	\label{UML Klassendiagramm für das Speichern und Laden}
\end{figure}

Die eigentliche Idee ist ganz einfach, jedes Objekt welches gespeichert werden soll, muss genau zwei Methoden zur Verfügung stellen, welche im Interface ISavable definiert sind:

\begin{itemize}
	\item \textit{string parameters2string()}
	
	Baue alle Informationen, die du dir merken willst, zu einem String zusammen.	
	\item \textit{void restorefromstring(string s)}	
	
	Stelle dich aus dem gebauten String wieder her.
\end{itemize}

Durch dieses Interface ist es dem \textit{File\_Manager} möglich alle Objekte dieses Interfaces speichern zu können. 
Er baut alle Informationen der Teilnehmer zu einem großen String zusammen, und kann diesen dann als Text-Datei abspeichern und selbstverständlich auch wieder herstellen.

Dieser Ansatz zum Speichern von Informationen kann nun auch natürlich für beliebige Klassen eingesetzt werden.

		\item \textbf{Wie können nun bereits bestehende Klassen gespeichert werden?}

Nun kann man sich vorstellen, dass es bereits sehr viele Standard-Klassen gibt, welche dieses Interface nicht implementieren. Im Falle des Live Tuners war es z.B. erforderlich Informationen über die WPF-Oberfläche wie TextBox, CheckBox, ComboBox, ... zu speichern.

Um hier Abhilfe zu schaffen, wurde die Klasse \textit{Savable\_WPF\_Obj} geschaffen, welche ganz genau weiß, wie eine TextBox, eine CheckBox, eine ComboBox, ... zu einem String gebaut wird, und auch wieder hergestellt wird.

Durch diesen kleinen Trick ist es nur noch erforderlich diesem Objekt zu sagen, welche WPF Objekte gespeichert werden sollen, und dann mittels des \textit{File\_Manager} zu speichern.
		
\end{description}